package SysMDCopyAst.functions

import ImportedSysMDExceptions.SemanticError
import ImportedSysMDQuantities.Quantity
import ImportedSysMDQuantities.VectorQuantity
import ImportedSysMDQuantities.ite
import ImportedSysMDServices.AgilaSession
import SysMDCopyAst.AstNode
import com.github.tukcps.jaadd.*

/**
 * The ITE function.
 * It uses lazy evaluation and takes three parameters:
 * - the first parameter is of type Bool.
 * - the second and third parameters are of arbitrary but equal type.
 * The result of the ITE function is the second parameter if the first is true,
 * else the third.
 */
class AstIte(model: AgilaSession, args: ArrayList<AstNode>) :
    AstFunction("ite", model, 3, args) {

    override fun initialize() {
        if (!parameters[0].isBool)
            throw SemanticError("ITE Function call, expected: 1st parameter of type BOOL, got: ${parameters[0].upQuantity}")

        /* Type checking here only at run-time. */
        when (parameters[1].upQuantity.values[0]) {
            is BDD -> {
                if (parameters[2].upQuantity.values[0] !is BDD)
                    throw SemanticError("Expect 3rd parameter of ite function of type Bool")
                upQuantity = VectorQuantity(mutableListOf(model.builder.Bool))
            }
            is IDD -> {
                if (parameters[2].upQuantity.values[0] !is IDD)
                    throw SemanticError("Expect 3rd parameter of ite function of type Int")
                upQuantity = VectorQuantity(mutableListOf(model.builder.Integers))
            }
            is AADD -> {
                if (parameters[2].upQuantity.values[0] !is AADD)
                    throw SemanticError("Expect 3rd parameter of ite function of type Bool")
                upQuantity = VectorQuantity(mutableListOf(model.builder.Reals),"?")
            }
            else -> throw SemanticError("ITE function only for Bool, AADD and IDD defined")
        }
        evalUp()
        downQuantity = upQuantity.clone()
    }

    /**
     * Here we just pass the 2nd or 3rd parameter up. the 1st is evaluated in evalUpRec.
     */
    @Throws(SemanticError::class)
    override fun evalUp() {
        val resultQuantities = mutableListOf<Quantity>()
        getBDDParam(0).upQuantity.values.indices.forEach {
            resultQuantities.add(getBDDParam(0).upQuantity.values[it].asBdd().ite(
                Quantity(getParam(1).upQuantity.values[it],getParam(1).upQuantity.unit,getParam(1).upQuantity.unitSpec),
                Quantity(getParam(2).upQuantity.values[it],getParam(2).upQuantity.unit,getParam(2).upQuantity.unitSpec)
            ))
        }
        val resultValues = mutableListOf<DD>()
        resultQuantities.forEach { resultValues.add(it.value) }
        upQuantity = VectorQuantity(resultValues,resultQuantities[0].unit,resultQuantities[0].unitSpec)
    }


    /**
     * ITE function with parameters with lazy evaluation.
     * We first evaluate the 1st parameter.
     * If it is true, the 2nd is evaluated.
     * if not, the 3rd is evaluated.
     * if the first parameter is both true and false, 2nd and 3rd are evaluated, and
     * the result is represented as a symbolic ITE representation in evalUp.
     */
    @Throws(SemanticError::class)
    override fun evalUpRec() {
        getParam(0).evalUpRec()
        // We do no lazy evaluation.
        getBDDParam(0)
        getParam(1).evalUpRec()
        getParam(2).evalUpRec()
        // now do ITE function.
        evalUp()
    }


    /**
     * ITE function from the result downwards computation.
     * As we work on BDD for the digital side that are generated by evalUp, evalDown does nothing.
     */
    override fun evalDown() {
    }


    override fun toExpressionString(): String {
        return "ITE(${getParam(0).toExpressionString()}, " +
                "${getParam(1).toExpressionString()}, " +
                "${getParam(2).toExpressionString()})"
    }

    /** Executes a block of statements on each AstNode in an Ast */
    override fun <T> runDepthFirst(block: AstNode.() -> T): T {
        for (p in parameters)
            p.runDepthFirst(block)
        return run(block)
    }

    override fun clone(): AstIte {
        val parClone = ArrayList<AstNode>()
        for (p in parameters) parClone.add(p.clone())
        return AstIte(model, parClone)
    }
}
