package SysMDRestImport.entities.user

import SysMDRestImport.entities.user.security.Constants
import SysMDRestImport.entities.user.security.Role
import SysMDRestImport.entities.user.security.SecurityGroup
import com.fasterxml.jackson.annotation.JsonIgnore
import com.fasterxml.jackson.annotation.JsonProperty
import java.io.Serializable
import java.util.*
import java.util.function.Consumer
import kotlin.collections.HashMap
import kotlin.collections.HashSet

/**
 * @author Khushnood Adil Rafique, Philipp Lersch
 */
//@Document("Users")
class User : Serializable, SecurityGroup {
    @JsonProperty("@id")
    var id: String? = null
    var userId: String? = null // public id, autmatically generated, not editable
    var firstName: String? = null // editable
    var lastName: String? = null // editable
    var email: String? = null // editable
    var password: String? = null // editable, converted by Spring to encrypted password.
    var encryptedPassword: String? = null // not editable, generated by Spring based on password
    var isDeleted = false // not editable
    var emailVerificationToken: String? = null //not implemented yet
    var isEmailVerificationStatus = false //not implemented yet

    @JsonIgnore
    private var securityContextMap: MutableMap<Role, Set<SecurityGroup?>?>

    //    @Ref
    var companyRef: Company? = null

    @JsonIgnore //    @Relations(edges = BelongsToGroup.class, lazy = true, direction = Relations.Direction.OUTBOUND)
    var userGroups: Collection<UserGroup>? = null

    constructor(
        userId: String?,
        firstName: String?,
        lastName: String?,
        email: String?,
        encryptedPassword: String?,
        isDeleted: Boolean,
        emailVerificationToken: String?,
        emailVerificationStatus: Boolean,
        securityContextMap: MutableMap<Role, Set<SecurityGroup?>?>?,
        companyRef: Company?,
        userGroups: Set<UserGroup>?
    ) {
        this.userId = userId
        this.firstName = firstName
        this.lastName = lastName
        this.email = email
        this.encryptedPassword = encryptedPassword
        this.isDeleted = isDeleted
        this.emailVerificationToken = emailVerificationToken
        isEmailVerificationStatus = emailVerificationStatus
        this.securityContextMap = ensureCorrectSecurityContext(securityContextMap)
        this.companyRef = companyRef
        this.userGroups = userGroups
    }

    constructor() {
        securityContextMap = ensureCorrectSecurityContext(null)
    }



    /** Set new Security Contexts
     * @param securityContextMap containing the new Security Contexts, can be empty or null to effectively remove all access including SecurityConstants.publicContext. Useful for disabled accounts
     */
    fun setSecurityContextMap(securityContextMap: MutableMap<Role, Set<SecurityGroup?>?>) {
        this.securityContextMap = Objects.requireNonNullElseGet(securityContextMap) { HashMap() }
        this.securityContextMap.remove(Role.USER)
        for (context in securityContextMap.values) {
            (context as HashMap<*, *>)
            context.remove(Constants.PUBLIC_GROUP)
            context.remove(this)
        }
    }

    override val securityIdentifier: String
        get() = (id + "_" + email + "_" + groupType).replace(' ', '-')
    override val parentGroup: SecurityGroup?
        get() = companyRef

    override fun equals(o: Any?): Boolean {
        if (this === o) return true
        if (o == null || javaClass != o.javaClass) return false
        val user = o as User
        return isDeleted == user.isDeleted && isEmailVerificationStatus == user.isEmailVerificationStatus && id == user.id && userId == user.userId && firstName == user.firstName && lastName == user.lastName && email == user.email && encryptedPassword == user.encryptedPassword && emailVerificationToken == user.emailVerificationToken && securityContextMap == user.securityContextMap && companyRef == user.companyRef && userGroups == user.userGroups
    }

    override fun hashCode(): Int {
        return Objects.hash(
            id,
            userId,
            firstName,
            lastName,
            email,
            encryptedPassword,
            isDeleted,
            emailVerificationToken,
            isEmailVerificationStatus,
            companyRef,
            userGroups
        )
    }

    val securityContextsAsString: String
        get() {
            val result = StringBuilder()
            securityContextMap.forEach { (k: Role?, v: Set<SecurityGroup?>?) ->
                result.append("Role: ").append(k).append(" for Groups: ")
                v!!.forEach(Consumer { group: SecurityGroup? ->
                    result.append(group!!.securityIdentifier).append(", ")
                })
            }
            return result.toString()
        }

    override fun toString(): String {
        return "User: " +
                "email='" + email + '\'' +
                ", id='" + id + '\'' +
                ", companyRef='" + companyRef!!.name + "':" + companyRef!!.id +
                ", userGroups=" + (userGroups?.joinToString { it.name.toString() } ?: "none") +
                ", userId='" + userId + '\'' +
                ", securityContextMap=" + securityContextsAsString +
                ", firstName='" + firstName + '\'' +
                ", lastName='" + lastName + '\'' +
                ", encryptedPassword='" + encryptedPassword + '\'' +
                ", isDeleted=" + isDeleted +
                ", emailVerificationToken='" + emailVerificationToken + '\'' +
                ", emailVerificationStatus=" + isEmailVerificationStatus
    }

    companion object {
        private const val serialVersionUID = 1034041405770047821L

        /** Checks that the default SecurityContexts are present.
         * At the moment these contain SecurityConstants.publicContext and the User:UserAsGroup Context.
         * !The last one is added in the getter as an workaround to keep the arango seralizer from stackoverflowing!
         * @param securityContextMap can be null or empty or filled as needed, information will only be added
         * @return 's a SecurityContextMap with the public context present
         */
        private fun ensureCorrectSecurityContext(securityContextMap: MutableMap<Role, Set<SecurityGroup?>?>?): MutableMap<Role, Set<SecurityGroup?>?> {
            // Catch null
            var securityContextMap = securityContextMap
            if (securityContextMap == null) securityContextMap = java.util.HashMap()
            // If entry present only add public group, If not set public context
            if (securityContextMap[Constants.PUBLIC_CONTEXT.role] == null) {
                securityContextMap[Constants.PUBLIC_CONTEXT.role] =
                    HashSet(Constants.PUBLIC_CONTEXT.getGroups())
            } else {
                val set = HashSet(securityContextMap[Constants.PUBLIC_CONTEXT.role])
                set.addAll(Constants.PUBLIC_CONTEXT.getGroups())
                securityContextMap[Constants.PUBLIC_CONTEXT.role] = set
            }
            // A User should always be able to manage himself and only himself. Can be removed by using the setter method
            // securityContextMap.put(Role.USER, Collections.singleton(this));
            // ToDo: As soon as this Context can be added permanently without crashing the arangoDB Seralizer this should be uncommented. Also see get-/setSecurityContextMap() for its To Do
            return securityContextMap
        }
    }
}
